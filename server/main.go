package main

import (
	"log"
	"net/http"
	"os"

	transcriptionHandlers "teammate/server/modules/transcription/interfaces/http/handlers"
	transcriptionRoutes "teammate/server/modules/transcription/interfaces/http/routes"
	"teammate/server/modules/user/interfaces/http/handlers"
	"teammate/server/modules/user/interfaces/http/routes"
	"teammate/server/seedwork/application/middleware"
	"teammate/server/seedwork/infrastructure/container"
	"teammate/server/seedwork/infrastructure/database"

	_ "teammate/server/docs" // This will be generated by swag init

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

// @title           Teammate API
// @version         1.0
// @description     A REST API for the Teammate application.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.teammate.com/support
// @contact.email  support@teammate.com

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and the Firebase ID token.

func main() {
	// Load .env file from project root
	if err := godotenv.Load(); err != nil {
		log.Println("Warning: .env file not found")
	}

	// Set Gin mode based on environment
	if os.Getenv("GIN_MODE") == "release" {
		gin.SetMode(gin.ReleaseMode)
	}

	// Initialize database connection
	if err := database.Initialize(); err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// Run database migrations
	migrationPath := os.Getenv("MIGRATION_PATH")
	if migrationPath == "" {
		migrationPath = "migrations" // Default path
	}

	if err := database.RunMigrations(migrationPath); err != nil {
		log.Fatalf("Failed to run migrations: %v", err)
	}

	// Initialize dependency injection container
	container, err := container.NewContainer()
	if err != nil {
		log.Fatalf("Failed to initialize container: %v", err)
	}

	// Create handlers
	userHandlers := handlers.NewUserHandlers(container.GetUserService(), container.GetFirebaseAuthService())
	audioHandlers := transcriptionHandlers.NewAudioHandlers()

	// Create routes
	userRoutes := routes.NewUserRoutes(userHandlers, container.GetAuthMiddleware())
	transcriptionRoutes := transcriptionRoutes.NewTranscriptionRoutes(audioHandlers)

	// Create a new Gin router
	router := gin.New()

	// Apply middleware
	router.Use(gin.Recovery())
	router.Use(middleware.Logger())
	router.Use(middleware.CORS())
	router.Use(middleware.ErrorHandler())

	// Add Swagger UI route (only in development)
	if gin.Mode() != gin.ReleaseMode {
		router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	}

	// Health check endpoint (public)
	// @Summary Health check endpoint
	// @Description Check if the API is running properly
	// @Tags health
	// @Produce json
	// @Success 200 {object} map[string]interface{}
	// @Router /health [get]
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "ok",
			"version": "1.0.0",
		})
	})

	// Public routes (no authentication required)
	public := router.Group("")
	userRoutes.SetupPublicRoutes(public)

	// Transcription routes (WebSocket doesn't work well with auth middleware)
	transcriptionRoutes.SetupRoutes(public)

	// Protected routes (authentication required)
	protected := router.Group("")
	userRoutes.SetupProtectedRoutes(protected)

	// Get port from environment or use default
	port := container.GetConfig().Server.Port
	if port == "" {
		port = "8080" // Default port
	}

	// Start the server
	log.Printf("Starting server on :%s", port)
	if err := router.Run(":" + port); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}
